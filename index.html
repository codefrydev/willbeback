<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- SEO Meta Tags -->
    <title>All-in-One Stream Dashboard | Live Stream Overlay Creator | CodeFryDev</title>
    <meta name="description" content="Create professional live stream overlays with our all-in-one dashboard. Customize titles, GIFs, countdown timers, social handles, and interactive elements for Twitch, YouTube, and more streaming platforms.">
    <meta name="keywords" content="stream dashboard, live stream overlay, twitch overlay, youtube streaming, stream graphics, countdown timer, social media handles, stream customization, live streaming tools">
    <meta name="author" content="CodeFryDev">
    <meta name="robots" content="index, follow">
    <meta name="language" content="en">
    <meta name="revisit-after" content="7 days">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="All-in-One Stream Dashboard | Live Stream Overlay Creator">
    <meta property="og:description" content="Create professional live stream overlays with our all-in-one dashboard. Customize titles, GIFs, countdown timers, social handles, and interactive elements for streaming platforms.">
    <meta property="og:url" content="https://codefrydev.in/willbeback/">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="CodeFryDev">
    <meta property="og:image" content="https://codefrydev.in/favicon-32x32.png">
    <meta property="og:image:width" content="32">
    <meta property="og:image:height" content="32">
    <meta property="og:image:alt" content="CodeFryDev Stream Dashboard">
    <meta property="og:locale" content="en_US">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="All-in-One Stream Dashboard | Live Stream Overlay Creator">
    <meta name="twitter:description" content="Create professional live stream overlays with our all-in-one dashboard. Customize titles, GIFs, countdown timers, social handles, and interactive elements for streaming platforms.">
    <meta name="twitter:image" content="https://codefrydev.in/favicon-32x32.png">
    <meta name="twitter:image:alt" content="CodeFryDev Stream Dashboard">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="https://codefrydev.in/favicon-32x32.png">
    <link rel="shortcut icon" href="https://codefrydev.in/favicon-32x32.png">
    <link rel="apple-touch-icon" href="https://codefrydev.in/favicon-32x32.png">

    <!-- Theme Color -->
    <meta name="theme-color" content="#0f172a">

    <!-- Performance: Preconnects -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://codefrydev.in/willbeback/">
    
    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "All-in-One Stream Dashboard",
        "description": "Create professional live stream overlays with our all-in-one dashboard. Customize titles, GIFs, countdown timers, social handles, and interactive elements for Twitch, YouTube, and more streaming platforms.",
        "url": "https://codefrydev.in/willbeback/",
        "applicationCategory": "MultimediaApplication",
        "operatingSystem": "Web Browser",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "creator": {
            "@type": "Organization",
            "name": "CodeFryDev",
            "url": "https://codefrydev.in"
        },
        "featureList": [
            "Live Stream Overlay Creation",
            "Customizable Titles and Graphics",
            "Countdown Timer Integration",
            "Social Media Handle Display",
            "Interactive Element Management",
            "Real-time Preview",
            "Drag and Drop Interface",
            "Multiple Element Types Support"
        ],
        "screenshot": "https://codefrydev.in/favicon-32x32.png",
        "softwareVersion": "1.0",
        "datePublished": "2024-01-01",
        "dateModified": "2024-12-19"
    }
    </script>
    
    <!-- FAQ Schema -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [
            {
                "@type": "Question",
                "name": "What is the All-in-One Stream Dashboard?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "The All-in-One Stream Dashboard is a web-based tool that allows streamers to create professional live stream overlays with customizable elements including titles, GIFs, countdown timers, social media handles, and interactive components."
                }
            },
            {
                "@type": "Question",
                "name": "How do I customize my stream overlay?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "You can customize your stream overlay by using the drag-and-drop interface to position elements, changing colors and fonts, uploading custom images and GIFs, setting countdown timers, and adding social media handles."
                }
            },
            {
                "@type": "Question",
                "name": "What streaming platforms does this work with?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "This dashboard works with all major streaming platforms including Twitch, YouTube Live, Facebook Gaming, and other OBS-compatible streaming software."
                }
            },
            {
                "@type": "Question",
                "name": "Is the Stream Dashboard free to use?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Yes, the All-in-One Stream Dashboard is completely free to use. No registration or payment required."
                }
            },
            {
                "@type": "Question",
                "name": "Can I save my overlay configurations?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Yes, your overlay configurations are automatically saved in your browser's local storage, so you can return to your customized settings anytime."
                }
            },
            {
                "@type": "Question",
                "name": "What file formats are supported for images and audio?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "For images, we support JPG, PNG, GIF, WebP, and SVG formats. For audio, we support MP3, WAV, OGG, and M4A formats. File size limits are 5MB for images and 10MB for audio files."
                }
            }
        ]
    }
    </script>
    
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-VM01Q3R43D" type="text/javascript" referrerpolicy="strict-origin-when-cross-origin"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-VM01Q3R43D');
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;900&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>

    <!-- Security Policies -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://www.googletagmanager.com https://www.google-analytics.com https://cdn.tailwindcss.com https://cdn.jsdelivr.net https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://cdnjs.cloudflare.com; img-src 'self' data: blob: https:; font-src 'self' https://fonts.gstatic.com https://cdnjs.cloudflare.com data:; connect-src 'self' https://www.google-analytics.com; media-src 'self' blob: data: https:; object-src 'none'; base-uri 'self'; frame-ancestors 'self'; upgrade-insecure-requests">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <meta http-equiv="Permissions-Policy" content="camera=(), microphone=(), geolocation=(), interest-cohort=()">
    <style>
        body { 
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 0;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .interactive-element {
            box-sizing: border-box; 
            touch-action: none;
            user-select: none;
            position: absolute;
        }
        .interactive-element.is-interacting {
            border: 2px dashed #38bdf8;
            z-index: 10;
        }
        .interactive-element > * {
            width: 100%;
            height: 100%;
        }
			/* Style for color input */
        input[type="color"] {
            -webkit-appearance: none;
            appearance: none;
            border: none;
				width: 28px;
				height: 28px;
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
			input[type="color"]::-webkit-color-swatch {
            border: 2px solid #4a5568;
            border-radius: 50%;
        }
        
        /* Hover effects for better UI/UX */
        .interactive-element:hover {
            border: 2px solid #10b981;
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.3);
        }
        
        .interactive-element.is-interacting:hover {
            border: 2px dashed #38bdf8;
            box-shadow: 0 0 25px rgba(56, 189, 248, 0.4);
        }
        
        
        input[type="text"]:hover, input[type="url"]:hover, input[type="number"]:hover, select:hover {
            border-color: #38bdf8;
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.2);
        }
        
        input[type="text"]:focus, input[type="url"]:focus, input[type="number"]:focus, select:focus {
            border-color: #38bdf8;
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.3);
            outline: none;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .bg-slate-800:hover {
            border-color: #38bdf8;
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.2);
        }
        
        /* Color input hover effect */
			input[type="color"]:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.3);
        }
        
        /* Checkbox hover effect */
        input[type="checkbox"]:hover {
            transform: scale(1.1);
        }
        
        /* Section headers hover effect */
        .bg-slate-900:hover {
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.1);
        }
        
        /* Alignment guide lines for drag/resize */
        .alignment-guide {
            position: absolute;
            background-color: rgba(56, 189, 248, 0.6);
            pointer-events: none;
            z-index: 25;
        }
        .alignment-guide.vertical { width: 2px; top: 0; bottom: 0; }
        .alignment-guide.horizontal { height: 2px; left: 0; right: 0; }
    </style>
</head>
<body class="bg-gray-800 text-white overflow-hidden">

    <!-- Controller UI -->
    <div id="controller-ui" class="p-4 h-screen overflow-y-auto">
        <div class="max-w-7xl mx-auto">
            <!-- Header -->
			<div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 mb-4">
				<h2 class="text-2xl font-bold text-cyan-400">Stream Dashboard</h2>
				<div class="w-full sm:w-auto flex items-center justify-between sm:justify-end gap-2">
					<!-- Profiles Toolbar -->
					<div class="flex items-center gap-2 bg-slate-800/60 border border-slate-700 rounded-lg p-2">
						<select id="profile-select" class="bg-slate-900 border border-slate-700 rounded-md px-2 h-9 text-sm min-w-[8rem]" title="Select profile">
							<option value="" selected disabled>Profiles</option>
						</select>
						<input id="profile-name-input" type="text" placeholder="Profile name" class="bg-slate-900 border border-slate-700 rounded-md px-2 h-9 text-sm w-36" title="New or existing profile name" />
						<div class="hidden sm:block h-9 w-px bg-slate-700"></div>
						<button id="save-profile-btn" title="Save profile" class="bg-emerald-500 hover:bg-emerald-600 text-white font-semibold px-2 py-1.5 rounded-md text-sm flex items-center gap-1">
							<i class="fas fa-save"></i><span class="hidden md:inline">Save</span>
						</button>
						<button id="load-profile-btn" title="Load selected profile" class="bg-sky-500 hover:bg-sky-600 text-white font-semibold px-2 py-1.5 rounded-md text-sm flex items-center gap-1">
							<i class="fas fa-download"></i><span class="hidden md:inline">Load</span>
						</button>
						<button id="delete-profile-btn" title="Delete selected profile" class="bg-rose-500 hover:bg-rose-600 text-white font-semibold px-2 py-1.5 rounded-md text-sm flex items-center gap-1">
							<i class="fas fa-trash"></i><span class="hidden md:inline">Delete</span>
						</button>
						<button id="export-profiles-btn" title="Export profiles JSON" class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold px-2 py-1.5 rounded-md text-sm flex items-center gap-1">
							<i class="fas fa-file-export"></i><span class="hidden md:inline">Export</span>
						</button>
						<button id="import-profiles-btn" title="Import profiles JSON" class="bg-violet-500 hover:bg-violet-600 text-white font-semibold px-2 py-1.5 rounded-md text-sm flex items-center gap-1">
							<i class="fas fa-file-import"></i><span class="hidden md:inline">Import</span>
						</button>
						<input id="import-file-input" type="file" accept="application/json" class="hidden">
					</div>

					<!-- Layout/Preview -->
					<div class="flex items-center gap-2">
						<button id="reset-position-btn" title="Reset all positions and elements" class="bg-amber-500 hover:bg-amber-600 text-white font-semibold px-3 py-1.5 rounded-md text-sm flex items-center gap-1">
							<i class="fas fa-rotate-left"></i><span class="hidden lg:inline">Reset</span>
						</button>
						<button id="toggle-view-btn" title="Toggle preview (Ctrl/Cmd + P)" class="bg-cyan-500 hover:bg-cyan-600 text-white font-semibold px-3 py-1.5 rounded-md text-sm flex items-center gap-1">
							<i class="fas fa-desktop"></i><span class="hidden lg:inline">Show Preview</span>
						</button>
					</div>
				</div>
			</div>

            <!-- Main Content Grid -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
                
                <!-- Left Column: Scene Settings & Core Elements -->
                <div class="space-y-4">
                    <!-- Scene Settings -->
                    <div class="bg-slate-900 p-4 rounded-lg shadow-xl">
                        <h2 class="text-lg font-bold text-slate-300 mb-3 border-b border-slate-700 pb-2">Scene Settings</h2>
                        <div class="space-y-3">
                            <div>
                                <label for="background-color-input" class="block text-sm font-medium text-slate-300 mb-1">Background Color</label>
                                <div class="flex items-center space-x-2">
							<input type="color" id="background-color-input">
							<input type="text" id="background-color-hex" class="flex-1 bg-slate-800 border border-slate-700 rounded-md px-3 h-9 text-sm">
                                </div>
                            </div>
                            <div>
                                <label for="background-image-input" class="block text-sm font-medium text-slate-300 mb-1">Background Image URL</label>
						<input type="url" id="background-image-input" class="w-full bg-slate-800 border border-slate-700 rounded-md px-3 h-9 text-sm" placeholder="https://...">
                            </div>
                        </div>
                    </div>

                    <!-- Core Elements -->
                    <div class="bg-slate-900 p-4 rounded-lg shadow-xl">
                        <h2 class="text-lg font-bold text-slate-300 mb-3 border-b border-slate-700 pb-2">Core Elements</h2>
                        <form id="controller-form" class="space-y-3">
                            <div class="flex items-end space-x-2">
                                <div class="flex-grow">
                                    <label for="main-title-input" class="block text-sm font-medium text-slate-300 mb-1">Main Title</label>
							<input type="text" id="main-title-input" class="w-full bg-slate-800 border border-slate-700 rounded-md px-3 h-9 text-sm">
                                </div>
                                <div>
                                    <label for="main-title-color-input" class="block text-sm font-medium text-slate-300 mb-1 text-center">Color</label>
							<input type="color" id="main-title-color-input">
                                </div>
                            </div>
                            <div>
                                <label for="gif-url-input" class="block text-sm font-medium text-slate-300 mb-1">Primary GIF/Image URL</label>
						<input type="url" id="gif-url-input" class="w-full bg-slate-800 border border-slate-700 rounded-md px-3 h-9 text-sm">
                            </div>
                            <div>
                                <label for="enable-timer-checkbox" class="flex items-center space-x-2 cursor-pointer">
                                    <input type="checkbox" id="enable-timer-checkbox" checked class="h-4 w-4 rounded bg-slate-800 border-slate-700 text-cyan-500 focus:ring-cyan-500">
                                    <span class="text-sm font-medium text-slate-300">Enable Countdown Timer</span>
                                </label>
                            </div>
					 <div id="timer-input-container">
					 	<label for="timer-minutes-input" class="block text-sm font-medium text-slate-300 mb-1">Countdown (Minutes)</label>
					 	<input type="number" id="timer-minutes-input" min="0" class="w-full bg-slate-800 border border-slate-700 rounded-md px-3 h-9 text-sm">
					 </div>
                             <div class="pt-2 border-t border-slate-700">
					 	<button id="add-core-text-btn" class="bg-cyan-500 hover:bg-cyan-600 text-white font-semibold px-3 py-1.5 rounded-md transition-colors shadow-md w-full text-sm">
                                     <i class="fas fa-plus mr-1"></i>Add Core Text Element
                                 </button>
                             </div>
                         </form>
                     </div>
                </div>

                <!-- Middle Column: Social Handles -->
                <div class="space-y-4">
                    <div class="bg-slate-900 p-4 rounded-lg shadow-xl">
                        <h2 class="text-lg font-bold text-slate-300 mb-3 border-b border-slate-700 pb-2">Social Handles</h2>
                        <div id="socials-form-container" class="space-y-2 mb-3">
                            <!-- Social handle forms will be injected here -->
                        </div>
					<button id="add-social-btn" class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold px-3 py-1.5 rounded-md transition-colors shadow-md w-full text-sm">
                            <i class="fas fa-plus mr-2"></i>Add Social
                        </button>
                    </div>
                </div>

                <!-- Right Column: Custom Elements -->
                <div class="space-y-4">
                    <div class="bg-slate-900 p-4 rounded-lg shadow-xl">
                        <h2 class="text-lg font-bold text-slate-300 mb-3 border-b border-slate-700 pb-2">Custom Elements</h2>
                        
                        <!-- Quick Add Buttons -->
                        <div class="space-y-3">
                            <!-- Text Elements -->
                            <div>
                                <h3 class="text-sm font-semibold text-slate-400 mb-2">Text</h3>
						<button id="add-text-btn" class="bg-green-500 hover:bg-green-600 text-white font-semibold px-3 py-1.5 rounded-md transition-colors shadow-md w-full text-sm">
                                    <i class="fas fa-plus mr-1"></i>Add Text
                                </button>
                            </div>
                            
                            <!-- Image Elements -->
                            <div>
                                <h3 class="text-sm font-semibold text-slate-400 mb-2">Images</h3>
                                <div class="grid grid-cols-2 gap-2">
							<button id="add-image-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold px-3 py-1.5 rounded-md transition-colors shadow-md text-xs">
                                        <i class="fas fa-image mr-1"></i>Image
                                    </button>
							<button id="add-gif-btn" class="bg-purple-500 hover:bg-purple-600 text-white font-semibold px-3 py-1.5 rounded-md transition-colors shadow-md text-xs">
                                        <i class="fas fa-play mr-1"></i>GIF
                                    </button>
							<button id="add-logo-btn" class="bg-orange-500 hover:bg-orange-600 text-white font-semibold px-3 py-1.5 rounded-md transition-colors shadow-md text-xs">
                                        <i class="fas fa-certificate mr-1"></i>Logo
                                    </button>
							<button id="add-banner-btn" class="bg-pink-500 hover:bg-pink-600 text-white font-semibold px-3 py-1.5 rounded-md transition-colors shadow-md text-xs">
                                        <i class="fas fa-flag mr-1"></i>Banner
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Audio Elements -->
                            <div>
                                <h3 class="text-sm font-semibold text-slate-400 mb-2">Audio</h3>
                                <div class="grid grid-cols-2 gap-2">
							<button id="add-audio-btn" class="bg-teal-500 hover:bg-teal-600 text-white font-semibold px-3 py-1.5 rounded-md transition-colors shadow-md text-xs">
                                        <i class="fas fa-music mr-1"></i>Audio
                                    </button>
							<button id="add-sound-effect-btn" class="bg-emerald-500 hover:bg-emerald-600 text-white font-semibold px-3 py-1.5 rounded-md transition-colors shadow-md text-xs">
                                        <i class="fas fa-volume-up mr-1"></i>Sound FX
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Dynamic Elements Container (Full Width Below) -->
            <div class="mt-4">
                <div id="dynamic-elements-form-container" class="space-y-3"></div>
            </div>
        </div>
    </div>

    <!-- The Live Preview Display -->
    <div id="display-view" class="hidden w-screen h-screen relative bg-slate-900">
        <div id="display-background" class="w-full h-full bg-cover bg-center">
            
            <!-- Static Elements -->
            <div id="title-container" class="interactive-element" tabindex="0">
                <h1 id="main-title" class="w-full h-full flex items-center justify-center text-center font-black uppercase tracking-wider drop-shadow-[0_4px_4px_rgba(0,0,0,0.5)]" style="font-size: 10vmin;"></h1>
            </div>
            <div id="gif-container" class="interactive-element" tabindex="0">
                 <img id="gif-display" src="" alt="Live Stream GIF" class="w-full h-full object-contain" loading="lazy" decoding="async">
            </div>
            <div id="timer-container" class="interactive-element" tabindex="0">
                <div class="w-full h-full flex items-center justify-center">
                    <div class="bg-cyan-500/80 text-white font-bold py-3 px-6 rounded-full inline-block shadow-lg text-center" style="font-size: 5vmin;">
                        Returning in: <span id="countdown" class="font-mono"></span>
                    </div>
                </div>
            </div>
            <div id="socials-container" class="interactive-element" tabindex="0">
                <div id="socials-display-wrapper" class="w-full h-full flex justify-center items-center flex-wrap gap-x-6 gap-y-2 text-slate-300 p-4">
                    <!-- Socials will be dynamically rendered here -->
                </div>
            </div>
            
            <div id="dynamic-elements-display-container"></div>

        </div>
        <!-- Alignment Guides -->
        <div id="v-guide" class="alignment-guide vertical" style="display: none;"></div>
        <div id="h-guide" class="alignment-guide horizontal" style="display: none;"></div>
        <button id="close-preview-btn" aria-label="Close preview" class="absolute top-4 right-4 bg-red-500 hover:bg-red-600 text-white font-bold p-2 rounded-full w-10 h-10 flex items-center justify-center transition-colors shadow-md z-20">
            <i class="fas fa-times text-xl"></i>
        </button>
    </div>

    <noscript>
        <div style="background:#0f172a;color:#e2e8f0;padding:12px;text-align:center;">
            This app requires JavaScript to customize and preview your overlay.
        </div>
    </noscript>

    <script>
        // --- FORM ELEMENTS ---
        const form = document.getElementById('controller-form');
        const titleInput = document.getElementById('main-title-input');
        const titleColorInput = document.getElementById('main-title-color-input');
        const gifUrlInput = document.getElementById('gif-url-input');
        const enableTimerCheckbox = document.getElementById('enable-timer-checkbox');
        const timerInputContainer = document.getElementById('timer-input-container');
        const timerMinutesInput = document.getElementById('timer-minutes-input');
        const bgColorInput = document.getElementById('background-color-input');
        const bgColorHex = document.getElementById('background-color-hex');
        const bgImageInput = document.getElementById('background-image-input');
        
        // --- DISPLAY CONTENT ELEMENTS ---
        const titleEl = document.getElementById('main-title');
        const gifEl = document.getElementById('gif-display');
        const countdownEl = document.getElementById('countdown');
        const displayBg = document.getElementById('display-background');

        // --- DISPLAY WRAPPER ELEMENTS ---
        const timerContainer = document.getElementById('timer-container');
        const socialsDisplayWrapper = document.getElementById('socials-display-wrapper');

        // --- SOCIALS ---
        const addSocialBtn = document.getElementById('add-social-btn');
        const socialsFormContainer = document.getElementById('socials-form-container');

        // --- DYNAMIC ELEMENTS ---
        const addTextBtn = document.getElementById('add-text-btn');
        const addImageBtn = document.getElementById('add-image-btn');
        const dynamicFormContainer = document.getElementById('dynamic-elements-form-container');
        const dynamicDisplayContainer = document.getElementById('dynamic-elements-display-container');

        // --- UI/TOGGLE ELEMENTS ---
        const toggleBtn = document.getElementById('toggle-view-btn');
        const controllerUi = document.getElementById('controller-ui');
        const displayView = document.getElementById('display-view');
        const closePreviewBtn = document.getElementById('close-preview-btn');
        const resetPositionBtn = document.getElementById('reset-position-btn');
        const vGuide = document.getElementById('v-guide');
        const hGuide = document.getElementById('h-guide');

		// --- PROFILES UI ---
		const profileSelect = document.getElementById('profile-select');
		const profileNameInput = document.getElementById('profile-name-input');
		const saveProfileBtn = document.getElementById('save-profile-btn');
		const loadProfileBtn = document.getElementById('load-profile-btn');
		const deleteProfileBtn = document.getElementById('delete-profile-btn');

        // --- STATE MANAGEMENT ---
        const staticElementStateKey = 'streamStaticElementsState';
        const dynamicElementStateKey = 'streamDynamicElementsState';
        const socialHandlesStateKey = 'streamSocialsState';
		const profilesKey = 'streamProfiles';
        let countdownInterval;
        let dynamicElements = [];
        let socialHandles = [];

        // --- UTILS ---
        function safeGetJSON(key, fallback) {
            try {
                const raw = localStorage.getItem(key);
                if (raw == null) return fallback;
                try { return JSON.parse(raw); } catch { return fallback; }
            } catch { return fallback; }
        }

        function safeSetJSON(key, value) {
            try { localStorage.setItem(key, JSON.stringify(value)); } catch {}
        }

        function isSafeUrl(url, options) {
            if (!url || typeof url !== 'string') return false;
            const trimmed = url.trim().toLowerCase();
            if (options && options.allowData && trimmed.startsWith('data:')) return true;
            return trimmed.startsWith('https://') || trimmed.startsWith('http://');
        }

        function setImgAttributes(imgEl) {
            if (!imgEl) return;
            imgEl.setAttribute('loading', 'lazy');
            imgEl.setAttribute('decoding', 'async');
            imgEl.setAttribute('referrerpolicy', 'no-referrer');
        }

        // --- DEFAULTS & CONFIG ---
        const socialIcons = {
            twitter: 'fa-brands fa-twitter',
            instagram: 'fa-brands fa-instagram',
            youtube: 'fa-brands fa-youtube',
            twitch: 'fa-brands fa-twitch',
            discord: 'fa-brands fa-discord',
            facebook: 'fa-brands fa-facebook',
            tiktok: 'fa-brands fa-tiktok',
            github: 'fa-brands fa-github',
            linkedin: 'fa-brands fa-linkedin',
            website: 'fas fa-globe'
        };

        const defaultContent = {
            title: "Be Right Back",
            titleColor: "#38bdf8",
            gifUrl: "https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExZzQ0dWpnemYzaDl2b2NqMmh6M3NmejVzZGNvbjBuc2U5cTY1bW1mZyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/VbnUQpnihPSIgIXuZv/giphy.gif",
            isTimerEnabled: true,
            timerMinutes: "1",
            bgColor: "#1e293b",
            bgImage: ""
        };

        const defaultStaticStates = {
            'title-container': { x: 0.25, y: 0.075, width: 0.5, height: 0.2 },
            'gif-container': { x: 0.3, y: 0.325, width: 0.4, height: 0.3 },
            'timer-container': { x: 0.25, y: 0.675, width: 0.5, height: 0.1 },
            'socials-container': { x: 0.25, y: 0.825, width: 0.5, height: 0.1 },
        };

        // --- CORE FUNCTIONS ---
        function toggleView() {
            controllerUi.classList.toggle('hidden');
            displayView.classList.toggle('hidden');
            if (!displayView.classList.contains('hidden')) {
                document.querySelectorAll('#title-container, #gif-container, #timer-container, #socials-container').forEach(el => {
                    applyState(el, staticElementStateKey, defaultStaticStates);
                });
                dynamicElements.forEach(dynEl => {
                    const displayEl = document.getElementById(dynEl.id);
                    if (displayEl) applyState(displayEl, dynamicElementStateKey, {});
                });
            }
        }

        function saveStaticContentData() {
            const data = {
                title: titleInput.value || defaultContent.title,
                titleColor: titleColorInput.value || defaultContent.titleColor,
                gifUrl: gifUrlInput.value || defaultContent.gifUrl,
                isTimerEnabled: enableTimerCheckbox.checked,
                timerMinutes: timerMinutesInput.value || defaultContent.timerMinutes,
                bgColor: bgColorInput.value || defaultContent.bgColor,
                bgImage: bgImageInput.value || defaultContent.bgImage,
            };
            safeSetJSON('streamScreenData', data);
            updateStaticDisplayContent(data);
        }
        
        function updateStaticDisplayContent(data) {
            titleEl.textContent = data.title;
            titleEl.style.color = data.titleColor;
            const safeGif = isSafeUrl(data.gifUrl, { allowData: true }) ? data.gifUrl : '';
            if (gifEl.src !== safeGif) gifEl.src = safeGif;
            setImgAttributes(gifEl);
            
            if (data.bgImage && isSafeUrl(data.bgImage, { allowData: true })) {
                displayBg.style.backgroundImage = `linear-gradient(rgba(15, 23, 42, 0.85), rgba(15, 23, 42, 0.95)), url('${data.bgImage}')`;
                displayBg.style.backgroundColor = '';
            } else {
                displayBg.style.backgroundImage = '';
                displayBg.style.backgroundColor = data.bgColor;
            }
            
            timerContainer.style.display = data.isTimerEnabled ? 'block' : 'none';
            if(data.isTimerEnabled) {
                startTimer(data.timerMinutes);
            } else {
                if (countdownInterval) clearInterval(countdownInterval);
            }
        }
        
        function startTimer(minutes) {
            if (countdownInterval) clearInterval(countdownInterval);
            let timeInSeconds = Math.max(0, parseInt(minutes, 10)) * 60;
            const update = () => {
                if (timeInSeconds < 0) {
                    clearInterval(countdownInterval);
                    countdownEl.textContent = "00:00";
                    return;
                }
                const mins = Math.floor(timeInSeconds / 60);
                let secs = timeInSeconds % 60;
                secs = secs < 10 ? '0' + secs : secs;
                countdownEl.textContent = `${mins}:${secs}`;
                timeInSeconds--;
            };
            update();
            countdownInterval = setInterval(update, 1000);
        }

        function loadStaticController() {
            const savedData = safeGetJSON('streamScreenData', {}) || {};
            titleInput.value = savedData.title || defaultContent.title;
            titleColorInput.value = savedData.titleColor || defaultContent.titleColor;
            gifUrlInput.value = savedData.gifUrl || defaultContent.gifUrl;
            enableTimerCheckbox.checked = savedData.isTimerEnabled ?? defaultContent.isTimerEnabled;
            timerMinutesInput.value = savedData.timerMinutes || defaultContent.timerMinutes;
            bgColorInput.value = savedData.bgColor || defaultContent.bgColor;
            bgColorHex.value = savedData.bgColor || defaultContent.bgColor;
            bgImageInput.value = savedData.bgImage || defaultContent.bgImage;
            timerInputContainer.classList.toggle('hidden', !enableTimerCheckbox.checked);
            saveStaticContentData();
        }

        // --- SOCIALS FUNCTIONS ---
        function saveSocials() {
            safeSetJSON(socialHandlesStateKey, socialHandles);
        }

        function loadSocials() {
            const saved = safeGetJSON(socialHandlesStateKey, null);
            if (saved) {
                socialHandles = saved;
                socialsFormContainer.innerHTML = '';
                socialHandles.forEach(renderSocialForm);
                renderSocialsDisplay();
            }
        }

        function addSocial() {
            const newSocial = {
                id: `social-${Date.now()}`,
                icon: 'twitter',
                text: '@handle'
            };
            socialHandles.push(newSocial);
            renderSocialForm(newSocial);
            renderSocialsDisplay();
            saveSocials();
        }

        function removeSocial(id) {
            socialHandles = socialHandles.filter(s => s.id !== id);
            document.getElementById(`form-${id}`).remove();
            renderSocialsDisplay();
            saveSocials();
        }
        
        function updateSocial(id, prop, value) {
            const social = socialHandles.find(s => s.id === id);
            if (social) {
                social[prop] = value;
                renderSocialsDisplay();
                saveSocials();
            }
        }

		function renderSocialForm(socialData) {
            const formCard = document.createElement('div');
            formCard.id = `form-${socialData.id}`;
			formCard.className = 'bg-slate-800 p-2 rounded-md border border-slate-700 flex items-center space-x-2';
            
            let options = '';
            for (const key in socialIcons) {
                options += `<option value="${key}" ${socialData.icon === key ? 'selected' : ''}>${key.charAt(0).toUpperCase() + key.slice(1)}</option>`;
            }

			formCard.innerHTML = `
				<select class="bg-slate-700 border border-slate-600 rounded-md px-2 h-8 text-xs w-24">${options}</select>
				<input type="text" value="${socialData.text}" class="flex-1 bg-slate-700 border border-slate-600 rounded-md px-2 h-8 text-xs" placeholder="@handle">
				<button class="text-red-500 hover:text-red-400 text-sm px-2">&times;</button>
			`;

            formCard.querySelector('select').onchange = (e) => updateSocial(socialData.id, 'icon', e.target.value);
            formCard.querySelector('input').oninput = (e) => updateSocial(socialData.id, 'text', e.target.value);
            formCard.querySelector('button').onclick = () => removeSocial(socialData.id);
            socialsFormContainer.appendChild(formCard);
        }

        function renderSocialsDisplay() {
            socialsDisplayWrapper.innerHTML = '';
            socialHandles.forEach(s => {
                const socialEl = document.createElement('div');
                socialEl.className = 'flex items-center space-x-2';
                const iconEl = document.createElement('i');
                iconEl.className = `${socialIcons[s.icon]} text-cyan-400`;
                iconEl.style.fontSize = '4vmin';
                const textEl = document.createElement('span');
                textEl.style.fontSize = '3.5vmin';
                textEl.textContent = s.text || '';
                socialEl.appendChild(iconEl);
                socialEl.appendChild(textEl);
                socialsDisplayWrapper.appendChild(socialEl);
            });
        }

        // --- DYNAMIC ELEMENT FUNCTIONS ---
        function saveDynamicElements() { safeSetJSON(dynamicElementStateKey, dynamicElements); }

        function loadDynamicElements() {
            const saved = safeGetJSON(dynamicElementStateKey, null);
            if (saved) {
                dynamicElements = saved;
                dynamicElements.forEach(renderDynamicElement);
            }
        }

        function addDynamicElement(type) {
            let defaultContent, defaultState;
            
            switch(type) {
                case 'text':
                    defaultContent = 'New Text';
                    defaultState = { x: 0.1, y: 0.1, width: 0.3, height: 0.15 };
                    break;
                case 'image':
                    defaultContent = 'https://placehold.co/400x200/0f172a/38bdf8?text=New+Image';
                    defaultState = { x: 0.1, y: 0.1, width: 0.3, height: 0.15 };
                    break;
                case 'gif':
                    defaultContent = 'https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExZzQ0dWpnemYzaDl2b2NqMmh6M3NmejVzZGNvbjBuc2U5cTY1bW1mZyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/VbnUQpnihPSIgIXuZv/giphy.gif';
                    defaultState = { x: 0.1, y: 0.1, width: 0.4, height: 0.2 };
                    break;
                case 'logo':
                    defaultContent = 'https://placehold.co/200x200/1e293b/38bdf8?text=LOGO';
                    defaultState = { x: 0.05, y: 0.05, width: 0.15, height: 0.15 };
                    break;
                case 'banner':
                    defaultContent = 'https://placehold.co/600x150/1e293b/38bdf8?text=BANNER';
                    defaultState = { x: 0.2, y: 0.05, width: 0.6, height: 0.1 };
                    break;
                case 'audio':
                    defaultContent = '';
                    defaultState = { x: 0.05, y: 0.9, width: 0.2, height: 0.05 };
                    break;
                case 'sound-effect':
                    defaultContent = '';
                    defaultState = { x: 0.75, y: 0.9, width: 0.2, height: 0.05 };
                    break;
                case 'core-text':
                    defaultContent = 'Core Text Element';
                    defaultState = { x: 0.1, y: 0.3, width: 0.8, height: 0.15 };
                    break;
                default:
                    defaultContent = 'https://placehold.co/400x200/0f172a/38bdf8?text=New+Element';
                    defaultState = { x: 0.1, y: 0.1, width: 0.3, height: 0.15 };
            }
            
            const newElement = {
                id: `dyn-${Date.now()}`,
                type: type,
                content: defaultContent,
                color: '#FFFFFF',
                state: defaultState
            };
            dynamicElements.push(newElement);
            renderDynamicElement(newElement);
            saveDynamicElements();
        }

        function removeDynamicElement(id) {
            dynamicElements = dynamicElements.filter(el => el.id !== id);
            document.getElementById(`form-${id}`)?.remove();
            document.getElementById(id)?.remove();
            saveDynamicElements();
        }

        function updateDynamicElement(id, prop, value) {
            const element = dynamicElements.find(el => el.id === id);
            if (element) {
                element[prop] = value;
                
                if (prop === 'content') {
                    // Clear file data when URL is updated
                    if (element.imageFile) {
                        if (element.imageFileUrl) {
                            URL.revokeObjectURL(element.imageFileUrl);
                        }
                        element.imageFile = null;
                        element.fileName = null;
                        element.imageFileUrl = null;
                    }
                    
                    // Update display based on element type
                    if (element.type === 'text' || element.type === 'core-text') {
                        const displayEl = document.getElementById(id).firstElementChild;
                        displayEl.textContent = value;
                    } else if (element.type === 'image' || element.type === 'gif' || element.type === 'logo' || element.type === 'banner') {
                        updateImageDisplay(id);
                    }
                } else if (prop === 'color') {
                    if (element.type === 'text' || element.type === 'core-text') {
                        const displayEl = document.getElementById(id).firstElementChild;
                        displayEl.style.color = value;
                    }
                }
                saveDynamicElements();
            }
        }

        function renderDynamicElement(elementData) {
            const formCard = document.createElement('div');
            formCard.id = `form-${elementData.id}`;
			formCard.className = 'bg-slate-800 p-2 rounded-md border border-slate-700';
            
            let label, inputType, colorPickerHTML = '';
            
            switch(elementData.type) {
                case 'text':
                    label = 'Text Content';
                    inputType = 'text';
                    colorPickerHTML = `<input type="color" value="${elementData.color}" class="ml-4">`;
                    break;
                case 'image':
                    label = 'Image URL';
                    inputType = 'url';
                    break;
                case 'gif':
                    label = 'GIF URL';
                    inputType = 'url';
                    break;
                case 'logo':
                    label = 'Logo URL';
                    inputType = 'url';
                    break;
                case 'banner':
                    label = 'Banner URL';
                    inputType = 'url';
                    break;
                case 'audio':
                    label = 'Audio URL';
                    inputType = 'url';
                    break;
                case 'sound-effect':
                    label = 'Sound Effect URL';
                    inputType = 'url';
                    break;
                case 'core-text':
                    label = 'Text Content';
                    inputType = 'text';
                    colorPickerHTML = `<input type="color" value="${elementData.color}" class="ml-4">`;
                    break;
                default:
                    label = 'Content URL';
                    inputType = 'url';
            }

            let audioControlsHTML = '';
            if (elementData.type === 'audio' || elementData.type === 'sound-effect') {
					audioControlsHTML = `
                    <div class="mt-3 space-y-3">
                        <div class="flex items-center space-x-2">
                            <label class="text-sm text-slate-300 font-medium">Upload Audio File:</label>
								<input type="file" class="audio-file-input" accept="audio/*" class="text-sm">
                        </div>
                        <div class="flex items-center space-x-2 flex-wrap gap-2">
								<button class="audio-play-btn bg-teal-500 hover:bg-teal-600 text-white px-2.5 py-1.5 rounded-md text-xs">
                                <i class="fas fa-play"></i> Play
                            </button>
								<button class="audio-stop-btn bg-red-500 hover:bg-red-600 text-white px-2.5 py-1.5 rounded-md text-xs">
                                <i class="fas fa-stop"></i> Stop
                            </button>
								<button class="audio-test-btn bg-blue-500 hover:bg-blue-600 text-white px-2.5 py-1.5 rounded-md text-xs">
                                <i class="fas fa-volume-up"></i> Test
                            </button>
                            <label class="flex items-center space-x-2 text-sm text-slate-300">
                                <input type="checkbox" class="audio-loop-checkbox" ${elementData.loop ? 'checked' : ''}>
                                <span>Loop</span>
                            </label>
                            <label class="flex items-center space-x-2 text-sm text-slate-300">
                                <span>Volume:</span>
									<input type="range" class="audio-volume-slider" min="0" max="100" value="${elementData.volume || 50}" class="w-20">
                            </label>
                        </div>
                        <div class="audio-file-info text-xs text-slate-400">
                            ${elementData.fileName ? `Current file: ${elementData.fileName}` : 'No file selected'}
                        </div>
                    </div>
                `;
            }

            let inputHTML = '';
            if (elementData.type === 'audio' || elementData.type === 'sound-effect') {
                inputHTML = ''; // No URL input for audio elements
            } else if (elementData.type === 'image' || elementData.type === 'gif' || elementData.type === 'logo' || elementData.type === 'banner') {
				inputHTML = `
					<div class="space-y-3">
						<div class="flex items-center space-x-2">
							<label class="text-sm text-slate-300 font-medium">Upload Image File:</label>
							<input type="file" class="image-file-input" accept="image/*" class="text-sm">
						</div>
						<div class="flex items-center space-x-2">
							<span class="text-sm text-slate-300">OR</span>
							<span class="text-sm text-slate-400">Enter URL:</span>
						</div>
						<div class="flex items-center">
							<input type="${inputType}" value="${elementData.content}" class="w-full bg-slate-700 border border-slate-600 rounded-md px-3 h-9 text-sm" placeholder="Enter ${label.toLowerCase()}...">
							${colorPickerHTML}
						</div>
						<div class="image-file-info text-xs text-slate-400">
							${elementData.fileName ? `Current file: ${elementData.fileName}` : 'No file selected'}
						</div>
					</div>
				`;
            } else {
				inputHTML = `
					<div class="flex items-center">
						<input type="${inputType}" value="${elementData.content}" class="w-full bg-slate-700 border border-slate-600 rounded-md px-3 h-9 text-sm" placeholder="Enter ${label.toLowerCase()}...">
						${colorPickerHTML}
					</div>
				`;
            }

            formCard.innerHTML = `
                <div class="flex justify-between items-center mb-2">
                    <label class="block text-sm font-medium text-slate-300 capitalize text-sm">${elementData.type} Element</label>
                    <button class="text-red-500 hover:text-red-400 text-sm">&times; Remove</button>
                </div>
                ${inputHTML}
                ${audioControlsHTML}
            `;
            formCard.querySelector('button').onclick = () => removeDynamicElement(elementData.id);
            
            // Set up input event listeners for non-audio elements
            if (elementData.type !== 'audio' && elementData.type !== 'sound-effect') {
                const urlInput = formCard.querySelector(`input[type="${inputType}"]`);
                if (urlInput) {
                    urlInput.oninput = (e) => {
                        updateDynamicElement(elementData.id, 'content', e.target.value);
                        
                        // Clear file info display when switching to URL
                        if (elementData.type === 'image' || elementData.type === 'gif' || elementData.type === 'logo' || elementData.type === 'banner') {
                            const imageFileInfo = formCard.querySelector('.image-file-info');
                            if (imageFileInfo) {
                                imageFileInfo.textContent = 'No file selected';
                            }
                        }
                    };
                }
            }
            
            // Image file upload event listeners
            if (elementData.type === 'image' || elementData.type === 'gif' || elementData.type === 'logo' || elementData.type === 'banner') {
                const imageFileInput = formCard.querySelector('.image-file-input');
                const imageFileInfo = formCard.querySelector('.image-file-info');
                
                if (imageFileInput && imageFileInfo) {
                    imageFileInput.onchange = (e) => handleImageFileUpload(elementData.id, e.target.files[0], imageFileInfo);
                }
            }
            
            if(elementData.type === 'text' || elementData.type === 'core-text') {
                const colorInput = formCard.querySelector('input[type="color"]');
                if (colorInput) {
                    colorInput.oninput = (e) => updateDynamicElement(elementData.id, 'color', e.target.value);
                }
            }
            
            // Audio controls event listeners
            if (elementData.type === 'audio' || elementData.type === 'sound-effect') {
                const fileInput = formCard.querySelector('.audio-file-input');
                const playBtn = formCard.querySelector('.audio-play-btn');
                const stopBtn = formCard.querySelector('.audio-stop-btn');
                const testBtn = formCard.querySelector('.audio-test-btn');
                const loopCheckbox = formCard.querySelector('.audio-loop-checkbox');
                const volumeSlider = formCard.querySelector('.audio-volume-slider');
                const fileInfo = formCard.querySelector('.audio-file-info');
                
                fileInput.onchange = (e) => handleAudioFileUpload(elementData.id, e.target.files[0], fileInfo);
                playBtn.onclick = () => playAudio(elementData.id);
                stopBtn.onclick = () => stopAudio(elementData.id);
                testBtn.onclick = () => testAudio(elementData.id);
                loopCheckbox.onchange = (e) => updateDynamicElement(elementData.id, 'loop', e.target.checked);
                volumeSlider.oninput = (e) => updateDynamicElement(elementData.id, 'volume', parseInt(e.target.value));
            }
            dynamicFormContainer.appendChild(formCard);

            const displayEl = document.createElement('div');
            displayEl.id = elementData.id;
            displayEl.className = 'interactive-element';
            
            switch(elementData.type) {
                case 'text':
                    displayEl.innerHTML = `<h2 class=\"flex items-center justify-center text-center p-2\" style=\"font-size: 5vmin; color: ${elementData.color};\"></h2>`;
                    displayEl.firstElementChild.textContent = elementData.content;
                    break;
                case 'core-text':
                    displayEl.innerHTML = `<h1 class=\"flex items-center justify-center text-center p-2 font-black uppercase tracking-wider drop-shadow-[0_4px_4px_rgba(0,0,0,0.5)]\" style=\"font-size: 8vmin; color: ${elementData.color};\"></h1>`;
                    displayEl.firstElementChild.textContent = elementData.content;
                    break;
                case 'image':
                case 'gif':
                case 'logo':
                case 'banner':
                    const hasImageFile = elementData.imageFile && elementData.fileName;
                    const imageSrc = hasImageFile ? URL.createObjectURL(elementData.imageFile) : (isSafeUrl(elementData.content, { allowData: true }) ? elementData.content : '');
                    displayEl.innerHTML = `<img src=\"${imageSrc}\" class=\"object-contain w-full h-full\" alt=\"${elementData.type} element\">`;
                    setImgAttributes(displayEl.firstElementChild);
                    break;
                case 'audio':
                case 'sound-effect':
                    const hasFile = elementData.audioFile && elementData.fileName;
                    displayEl.innerHTML = `
                        <div class="w-full h-full flex items-center justify-center bg-slate-700 rounded-lg border-2 border-teal-500">
                            <div class="text-center">
                                <i class="fas fa-music text-teal-400 text-4xl mb-2"></i>
                                <div class="text-teal-300 text-sm font-medium">${elementData.type === 'audio' ? 'Audio' : 'Sound Effect'}</div>
                                <div class="text-slate-400 text-xs mt-1">
                                    ${hasFile ? 'Click to play' : 'Upload file to play'}
                                </div>
                                ${hasFile ? `<div class="text-slate-500 text-xs mt-1">${elementData.fileName}</div>` : ''}
                            </div>
                        </div>
                    `;
                    break;
                default:
                    displayEl.innerHTML = `<img src=\"${isSafeUrl(elementData.content, { allowData: true }) ? elementData.content : ''}\" class=\"object-contain w-full h-full\" alt=\"${elementData.type} element\">`;
                    setImgAttributes(displayEl.firstElementChild);
                    break;
            }
            
            // Add click-to-play for audio elements
            if (elementData.type === 'audio' || elementData.type === 'sound-effect') {
                displayEl.onclick = () => {
                    if (elementData.audioFile) {
                        playAudio(elementData.id);
                    } else {
                        alert('Please upload an audio file first.');
                    }
                };
                displayEl.style.cursor = elementData.audioFile ? 'pointer' : 'default';
            }
            
            dynamicDisplayContainer.appendChild(displayEl);
            applyState(displayEl, dynamicElementStateKey, {});
            displayEl.setAttribute('tabindex', '0');
        }
        
        // --- AUDIO FUNCTIONS ---
        function handleAudioFileUpload(elementId, file, fileInfoElement) {
            if (!file) return;
            
            console.log('File selected:', file.name, 'Type:', file.type, 'Size:', file.size);
            
            // Validate file type
            if (!file.type.startsWith('audio/')) {
                alert('Please select a valid audio file. Supported formats: MP3, WAV, OGG, M4A, etc.');
                return;
            }
            
            // Validate file size (max 10MB)
            if (file.size > 10 * 1024 * 1024) {
                alert('Audio file is too large. Please select a file smaller than 10MB.');
                return;
            }
            
            const element = dynamicElements.find(el => el.id === elementId);
            if (!element) return;
            
            // Clean up previous audio if exists
            if (element.currentAudio) {
                cleanupAudio(elementId);
            }
            
            // Store file data
            element.audioFile = file;
            element.fileName = file.name;
            element.fileSize = (file.size / 1024 / 1024).toFixed(2) + ' MB';
            
            // Update file info display
            fileInfoElement.textContent = `Current file: ${file.name} (${element.fileSize})`;
            
            // Save the element data
            saveDynamicElements();
            
            console.log('Audio file uploaded successfully:', element.fileName);
        }
        
        function testAudio(elementId) {
            const element = dynamicElements.find(el => el.id === elementId);
            if (!element || !element.audioFile) {
                alert('Please upload an audio file first.');
                return;
            }
            
            console.log('Testing audio for element:', elementId);
            console.log('File:', element.fileName, 'Type:', element.audioFile.type);
            
            // Create a test audio element
            const audioUrl = URL.createObjectURL(element.audioFile);
            const testAudio = new Audio(audioUrl);
            
            testAudio.onloadeddata = () => {
                console.log('Test audio loaded successfully');
                alert('Audio file loaded successfully! File format is supported.');
                URL.revokeObjectURL(audioUrl);
            };
            
            testAudio.onerror = (error) => {
                console.error('Test audio error:', error);
                alert('Error loading audio file. Please check the file format.');
                URL.revokeObjectURL(audioUrl);
            };
            
            testAudio.load();
        }
        
        function playAudio(elementId) {
            const element = dynamicElements.find(el => el.id === elementId);
            if (!element || !element.audioFile) {
                alert('Please upload an audio file first.');
                return;
            }
            
            // Stop any currently playing audio
            stopAllAudio();
            
            // Create audio from file
            const audioUrl = URL.createObjectURL(element.audioFile);
            const audio = new Audio(audioUrl);
            audio.volume = (element.volume || 50) / 100;
            audio.loop = element.loop || false;
            
            // Store reference to current audio and URL for cleanup
            element.currentAudio = audio;
            element.currentAudioUrl = audioUrl;
            
            // Set up event handlers
            audio.onloadeddata = () => {
                console.log('Audio loaded successfully');
                // Try to play after loading
                audio.play().catch(error => {
                    console.error('Error playing audio:', error);
                    if (error.name === 'NotAllowedError') {
                        alert('Browser blocked audio playback. Please click the play button again.');
                    } else {
                        alert('Error playing audio. Please check the file and try again.');
                    }
                    cleanupAudio(elementId);
                });
            };
            
            audio.onerror = (error) => {
                console.error('Audio loading error:', error);
                alert('Error loading audio file. Please check the file format and try again.');
                cleanupAudio(elementId);
            };
            
            audio.onended = () => {
                console.log('Audio playback ended');
                cleanupAudio(elementId);
            };
            
            audio.onpause = () => {
                console.log('Audio paused');
            };
            
            // Update play button state immediately
            updatePlayButtonState(elementId, 'playing');
            
            // Start loading the audio
            audio.load();
        }
        
        function cleanupAudio(elementId) {
            const element = dynamicElements.find(el => el.id === elementId);
            if (!element) return;
            
            if (element.currentAudio) {
                element.currentAudio.pause();
                element.currentAudio.currentTime = 0;
                element.currentAudio = null;
            }
            
            if (element.currentAudioUrl) {
                URL.revokeObjectURL(element.currentAudioUrl);
                element.currentAudioUrl = null;
            }
            
            updatePlayButtonState(elementId, 'stopped');
        }
        
        function updatePlayButtonState(elementId, state) {
            const formCard = document.getElementById(`form-${elementId}`);
            if (!formCard) return;
            
            const playBtn = formCard.querySelector('.audio-play-btn');
            if (!playBtn) return;
            
            switch(state) {
                case 'playing':
                    playBtn.innerHTML = '<i class="fas fa-pause"></i> Pause';
                    playBtn.classList.remove('bg-teal-500', 'hover:bg-teal-600');
                    playBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
                    playBtn.onclick = () => pauseAudio(elementId);
                    break;
                case 'paused':
                case 'stopped':
                    playBtn.innerHTML = '<i class="fas fa-play"></i> Play';
                    playBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
                    playBtn.classList.add('bg-teal-500', 'hover:bg-teal-600');
                    playBtn.onclick = () => playAudio(elementId);
                    break;
            }
        }
        
        function pauseAudio(elementId) {
            const element = dynamicElements.find(el => el.id === elementId);
            if (!element || !element.currentAudio) return;
            
            element.currentAudio.pause();
            updatePlayButtonState(elementId, 'paused');
        }
        
        function stopAudio(elementId) {
            cleanupAudio(elementId);
        }
        
        function stopAllAudio() {
            dynamicElements.forEach(element => {
                if (element.currentAudio) {
                    element.currentAudio.pause();
                    element.currentAudio.currentTime = 0;
                    if (element.currentAudioUrl) {
                        URL.revokeObjectURL(element.currentAudioUrl);
                        element.currentAudioUrl = null;
                    }
                    element.currentAudio = null;
                }
            });
        }
        
        // --- IMAGE FILE FUNCTIONS ---
        function handleImageFileUpload(elementId, file, fileInfoElement) {
            if (!file) return;
            
            console.log('Image file selected:', file.name, 'Type:', file.type, 'Size:', file.size);
            
            // Validate file type
            if (!file.type.startsWith('image/')) {
                alert('Please select a valid image file. Supported formats: JPG, PNG, GIF, WebP, SVG, etc.');
                return;
            }
            
            // Validate file size (max 5MB for images)
            if (file.size > 5 * 1024 * 1024) {
                alert('Image file is too large. Please select a file smaller than 5MB.');
                return;
            }
            
            const element = dynamicElements.find(el => el.id === elementId);
            if (!element) return;
            
            // Clean up previous image file if exists
            if (element.imageFile && element.imageFileUrl) {
                URL.revokeObjectURL(element.imageFileUrl);
            }
            
            // Store file data
            element.imageFile = file;
            element.fileName = file.name;
            element.fileSize = (file.size / 1024 / 1024).toFixed(2) + ' MB';
            
            // Update file info display
            fileInfoElement.textContent = `Current file: ${file.name} (${element.fileSize})`;
            
            // Save the element data
            saveDynamicElements();
            
            // Update the display
            updateImageDisplay(elementId);
            
            console.log('Image file uploaded successfully:', element.fileName);
        }
        
        function updateImageDisplay(elementId) {
            const element = dynamicElements.find(el => el.id === elementId);
            if (!element) return;
            
            const displayEl = document.getElementById(elementId);
            if (!displayEl) return;
            
            const hasImageFile = element.imageFile && element.fileName;
            const imageSrc = hasImageFile ? URL.createObjectURL(element.imageFile) : (isSafeUrl(element.content, { allowData: true }) ? element.content : '');
            
            // Clean up old URL if switching from file to URL
            if (!hasImageFile && element.imageFileUrl) {
                URL.revokeObjectURL(element.imageFileUrl);
                element.imageFileUrl = null;
            } else if (hasImageFile) {
                element.imageFileUrl = imageSrc;
            }
            
            displayEl.innerHTML = `<img src=\"${imageSrc}\" class=\"object-contain w-full h-full\" alt=\"${element.type} element\">`;
            setImgAttributes(displayEl.firstElementChild);
        }
        
        // --- INTERACT.JS LOGIC ---
        function updateAlignmentGuides(target) {
            // Kept for backward compatibility: show center guides if close.
            if (displayView.classList.contains('hidden')) return;
            const parentWidth = displayView.clientWidth;
            const parentHeight = displayView.clientHeight;
            if (!parentWidth || !parentHeight) return;

            const x = parseFloat(target.getAttribute('data-x')) || 0;
            const y = parseFloat(target.getAttribute('data-y')) || 0;
            const w = target.offsetWidth;
            const h = target.offsetHeight;

            const centerX = parentWidth / 2;
            const centerY = parentHeight / 2;
            const elCenterX = x + w / 2;
            const elCenterY = y + h / 2;
            const threshold = 8; // px

            if (Math.abs(elCenterX - centerX) <= threshold) {
                vGuide.style.left = centerX + 'px';
                vGuide.style.display = 'block';
            } else {
                vGuide.style.display = 'none';
            }

            if (Math.abs(elCenterY - centerY) <= threshold) {
                hGuide.style.top = centerY + 'px';
                hGuide.style.display = 'block';
            } else {
                hGuide.style.display = 'none';
            }
        }

        function hideAlignmentGuides() {
            vGuide.style.display = 'none';
            hGuide.style.display = 'none';
        }

        function collectAlignmentTargets(excludeEl) {
            const parentWidth = displayView.clientWidth;
            const parentHeight = displayView.clientHeight;
            const vertical = [parentWidth / 2];
            const horizontal = [parentHeight / 2];
            const elements = displayView.querySelectorAll('.interactive-element');
            elements.forEach(el => {
                if (el === excludeEl) return;
                const ex = parseFloat(el.getAttribute('data-x')) || 0;
                const ey = parseFloat(el.getAttribute('data-y')) || 0;
                const ew = el.offsetWidth;
                const eh = el.offsetHeight;
                vertical.push(ex, ex + ew / 2, ex + ew);
                horizontal.push(ey, ey + eh / 2, ey + eh);
            });
            return { vertical, horizontal };
        }

        function computeNearest(anchors, targets, threshold) {
            let best = { delta: 0, guide: null, dist: Infinity };
            anchors.forEach(anchor => {
                targets.forEach(t => {
                    const d = Math.abs(t - anchor);
                    if (d < best.dist) { best = { delta: t - anchor, guide: t, dist: d }; }
                });
            });
            if (best.dist <= threshold) return best;
            return null;
        }

        function showGuides(vx, hy) {
            if (typeof vx === 'number') { vGuide.style.left = vx + 'px'; vGuide.style.display = 'block'; } else { vGuide.style.display = 'none'; }
            if (typeof hy === 'number') { hGuide.style.top = hy + 'px'; hGuide.style.display = 'block'; } else { hGuide.style.display = 'none'; }
        }

        function applyDragSnap(target, x, y) {
            const threshold = 8;
            const w = target.offsetWidth;
            const h = target.offsetHeight;
            const anchorsX = [x, x + w / 2, x + w];
            const anchorsY = [y, y + h / 2, y + h];
            const { vertical, horizontal } = collectAlignmentTargets(target);

            const vx = computeNearest(anchorsX, vertical, threshold);
            const hy = computeNearest(anchorsY, horizontal, threshold);

            const snappedX = vx ? x + vx.delta : x;
            const snappedY = hy ? y + hy.delta : y;

            showGuides(vx ? vx.guide : null, hy ? hy.guide : null);

            return { x: snappedX, y: snappedY };
        }

        function applyResizeSnap(target, x, y, width, height, edges) {
            const threshold = 8;
            const right = x + width;
            const bottom = y + height;
            const { vertical, horizontal } = collectAlignmentTargets(target);

            let snappedVX = null;
            if (edges && (edges.left || edges.right)) {
                const anchors = [];
                if (edges.left) anchors.push(x);
                if (edges.right) anchors.push(right);
                const best = computeNearest(anchors, vertical, threshold);
                if (best) {
                    // Decide which edge snapped by comparing which anchor matched
                    const leftDist = Math.abs(best.guide - x);
                    const rightDist = Math.abs(best.guide - right);
                    if (edges.left && (!edges.right || leftDist <= rightDist)) {
                        // Snap left, keep right constant
                        x = best.guide;
                        width = Math.max(0, right - x);
                        snappedVX = best.guide;
                    } else if (edges.right) {
                        // Snap right, keep left constant
                        width = Math.max(0, best.guide - x);
                        snappedVX = best.guide;
                    }
                }
            }

            let snappedHY = null;
            if (edges && (edges.top || edges.bottom)) {
                const anchors = [];
                if (edges.top) anchors.push(y);
                if (edges.bottom) anchors.push(bottom);
                const best = computeNearest(anchors, horizontal, threshold);
                if (best) {
                    const topDist = Math.abs(best.guide - y);
                    const bottomDist = Math.abs(best.guide - bottom);
                    if (edges.top && (!edges.bottom || topDist <= bottomDist)) {
                        y = best.guide;
                        height = Math.max(0, bottom - y);
                        snappedHY = best.guide;
                    } else if (edges.bottom) {
                        height = Math.max(0, best.guide - y);
                        snappedHY = best.guide;
                    }
                }
            }

            showGuides(snappedVX, snappedHY);

            return { x, y, width, height };
        }
        function applyState(element, stateKey, defaultStates) {
            const id = element.id;
            const savedStates = safeGetJSON(stateKey, {}) || {};
            let state;
            if (stateKey === dynamicElementStateKey) {
                 const dynEl = dynamicElements.find(e => e.id === id);
                 state = dynEl ? dynEl.state : { x: 0.1, y: 0.1, width: 0.3, height: 0.15 };
            } else {
                state = savedStates[id] || defaultStates[id];
            }
            const parentWidth = displayView.clientWidth;
            const parentHeight = displayView.clientHeight;
            if(parentWidth === 0 || parentHeight === 0) return;
            const newWidth = parentWidth * state.width;
            const newHeight = parentHeight * state.height;
            const x = parentWidth * state.x;
            const y = parentHeight * state.y;
            element.style.width = `${newWidth}px`;
            element.style.height = `${newHeight}px`;
            element.style.transform = `translate(${x}px, ${y}px)`;
            element.setAttribute('data-x', x);
            element.setAttribute('data-y', y);
        }
        
        interact('.interactive-element').draggable({
            modifiers: [
                interact.modifiers.snap({
                    targets: [interact.snappers.grid({ x: 10, y: 10 })],
                    range: 8
                })
            ],
            listeners: {
                start(event) { 
                    event.target.classList.add('is-interacting'); 
                    const x0 = parseFloat(event.target.getAttribute('data-x')) || 0;
                    const y0 = parseFloat(event.target.getAttribute('data-y')) || 0;
                    applyDragSnap(event.target, x0, y0);
                },
                move(event) {
                    let target = event.target;
                    let x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
                    let y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
                    const snapped = applyDragSnap(target, x, y);
                    x = snapped.x; y = snapped.y;
                    target.style.transform = `translate(${x}px, ${y}px)`;
                    target.setAttribute('data-x', x);
                    target.setAttribute('data-y', y);
                },
                end(event) {
                    event.target.classList.remove('is-interacting');
                    hideAlignmentGuides();
                    const isStatic = !!defaultStaticStates[event.target.id];
                    const stateKey = isStatic ? staticElementStateKey : dynamicElementStateKey;
                    const id = event.target.id;
                    const parentWidth = displayView.clientWidth;
                    const parentHeight = displayView.clientHeight;
                    const newX = (parseFloat(event.target.getAttribute('data-x')) || 0) / parentWidth;
                    const newY = (parseFloat(event.target.getAttribute('data-y')) || 0) / parentHeight;

                    if (isStatic) {
                        const savedStates = safeGetJSON(stateKey, { ...defaultStaticStates });
                        savedStates[id] = { ...savedStates[id], x: newX, y: newY };
                        safeSetJSON(stateKey, savedStates);
                    } else {
                        const dynEl = dynamicElements.find(e => e.id === id);
                        if (dynEl) { dynEl.state.x = newX; dynEl.state.y = newY; saveDynamicElements(); }
                    }
                }
            }
        }).resizable({
            edges: { left: true, right: true, bottom: true, top: true },
            modifiers: [
                interact.modifiers.snapSize({
                    targets: [interact.snappers.grid({ x: 10, y: 10 })]
                })
            ],
            listeners: {
                start(event) { 
                    event.target.classList.add('is-interacting'); 
                    const x0 = parseFloat(event.target.getAttribute('data-x')) || 0;
                    const y0 = parseFloat(event.target.getAttribute('data-y')) || 0;
                    applyDragSnap(event.target, x0, y0);
                },
                move(event) {
                    let target = event.target;
                    let x = parseFloat(target.getAttribute('data-x')) || 0;
                    let y = parseFloat(target.getAttribute('data-y')) || 0;
                    let width = event.rect.width;
                    let height = event.rect.height;
                    x += event.deltaRect.left;
                    y += event.deltaRect.top;
                    const snapped = applyResizeSnap(target, x, y, width, height, event.edges || {});
                    x = snapped.x; y = snapped.y; width = snapped.width; height = snapped.height;
                    target.style.width = width + 'px';
                    target.style.height = height + 'px';
                    target.style.transform = 'translate(' + x + 'px,' + y + 'px)';
                    target.setAttribute('data-x', x);
                    target.setAttribute('data-y', y);
                },
                end(event) {
                    event.target.classList.remove('is-interacting');
                    hideAlignmentGuides();
                    const isStatic = !!defaultStaticStates[event.target.id];
                    const stateKey = isStatic ? staticElementStateKey : dynamicElementStateKey;
                    const id = event.target.id;
                    const parentWidth = displayView.clientWidth;
                    const parentHeight = displayView.clientHeight;
                    const newX = (parseFloat(event.target.getAttribute('data-x')) || 0) / parentWidth;
                    const newY = (parseFloat(event.target.getAttribute('data-y')) || 0) / parentHeight;
                    const newWidth = (event.target.offsetWidth) / parentWidth;
                    const newHeight = (event.target.offsetHeight) / parentHeight;
                    if (isStatic) {
                        const savedStates = safeGetJSON(stateKey, { ...defaultStaticStates });
                        savedStates[id] = { width: newWidth, height: newHeight, x: newX, y: newY };
                        safeSetJSON(stateKey, savedStates);
                    } else {
                        const dynEl = dynamicElements.find(e => e.id === id);
                        if (dynEl) { dynEl.state = { width: newWidth, height: newHeight, x: newX, y: newY }; saveDynamicElements(); }
                    }
                }
            }
        });

		// --- PROFILES MANAGEMENT ---
		function getProfilesMap() {
			return safeGetJSON(profilesKey, {});
		}

		function saveProfilesMap(map) {
			safeSetJSON(profilesKey, map);
		}

		function refreshProfileList(selectedName) {
			const map = getProfilesMap();
			const names = Object.keys(map).sort((a, b) => a.localeCompare(b));
			// Preserve the first placeholder option
			while (profileSelect.options.length > 1) { profileSelect.remove(1); }
			names.forEach(name => {
				const opt = document.createElement('option');
				opt.value = name;
				opt.textContent = name;
				profileSelect.appendChild(opt);
			});
			if (selectedName && names.includes(selectedName)) {
				profileSelect.value = selectedName;
				profileNameInput.value = selectedName;
			} else {
				profileSelect.value = '';
			}
		}

		function snapshotCurrentConfig() {
			// Ensure latest data is saved to localStorage
			saveStaticContentData();
			saveSocials();
			saveDynamicElements();

			return {
				streamScreenData: localStorage.getItem('streamScreenData') || JSON.stringify(defaultContent),
				staticElementState: localStorage.getItem(staticElementStateKey) || JSON.stringify(defaultStaticStates),
				dynamicElementState: localStorage.getItem(dynamicElementStateKey) || '[]',
				socialHandlesState: localStorage.getItem(socialHandlesStateKey) || '[]',
				_savedAt: new Date().toISOString()
			};
		}

		function applyProfileSnapshot(snapshot) {
			if (!snapshot) return;
			localStorage.setItem('streamScreenData', snapshot.streamScreenData || JSON.stringify(defaultContent));
			localStorage.setItem(staticElementStateKey, snapshot.staticElementState || JSON.stringify(defaultStaticStates));
			localStorage.setItem(dynamicElementStateKey, snapshot.dynamicElementState || '[]');
			localStorage.setItem(socialHandlesStateKey, snapshot.socialHandlesState || '[]');

			// Reset current UI state and reload from localStorage
			dynamicElements = [];
			socialHandles = [];
			dynamicFormContainer.innerHTML = '';
			dynamicDisplayContainer.innerHTML = '';
			socialsFormContainer.innerHTML = '';

			loadStaticController();
			loadSocials();
			loadDynamicElements();
			// Re-apply positions for static elements if preview is open
			document.querySelectorAll('#title-container, #gif-container, #timer-container, #socials-container').forEach(el => applyState(el, staticElementStateKey, defaultStaticStates));
		}

		function saveCurrentAsProfile() {
			const name = (profileNameInput.value || '').trim();
			if (!name) { alert('Please enter a profile name.'); return; }
			const profiles = getProfilesMap();
			if (profiles[name] && !confirm(`Profile "${name}" exists. Overwrite?`)) { return; }
			profiles[name] = snapshotCurrentConfig();
			saveProfilesMap(profiles);
			refreshProfileList(name);
			alert('Profile saved.');
		}

		function loadSelectedProfile() {
			const name = profileSelect.value;
			if (!name) { alert('Please select a profile to load.'); return; }
			const profiles = getProfilesMap();
			if (!profiles[name]) { alert('Selected profile not found.'); return; }
			applyProfileSnapshot(profiles[name]);
		}

		function deleteSelectedProfile() {
			const name = profileSelect.value || (profileNameInput.value || '').trim();
			if (!name) { alert('Please select or enter a profile to delete.'); return; }
			const profiles = getProfilesMap();
			if (!profiles[name]) { alert('Profile not found.'); return; }
			if (!confirm(`Delete profile "${name}"? This cannot be undone.`)) { return; }
			delete profiles[name];
			saveProfilesMap(profiles);
			refreshProfileList('');
			alert('Profile deleted.');
		}

        // --- EVENT LISTENERS ---
        window.addEventListener('load', () => {
            loadStaticController();
            loadSocials();
            loadDynamicElements();
            document.querySelectorAll('#title-container, #gif-container, #timer-container, #socials-container').forEach(el => applyState(el, staticElementStateKey, defaultStaticStates));
			refreshProfileList();
        });

        document.getElementById('controller-ui').addEventListener('input', saveStaticContentData);
        bgColorInput.addEventListener('input', (e) => { bgColorHex.value = e.target.value; });
        bgColorHex.addEventListener('input', (e) => { bgColorInput.value = e.target.value; });

        enableTimerCheckbox.addEventListener('change', () => {
            timerInputContainer.classList.toggle('hidden', !enableTimerCheckbox.checked);
        });

        toggleBtn.addEventListener('click', toggleView);
        closePreviewBtn.addEventListener('click', toggleView);
        resetPositionBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to reset the layout for ALL elements? This will also remove all custom and social elements.')) {
                localStorage.removeItem(staticElementStateKey);
                localStorage.removeItem(dynamicElementStateKey);
                localStorage.removeItem(socialHandlesStateKey);
                dynamicElements = [];
                socialHandles = [];
                dynamicFormContainer.innerHTML = '';
                dynamicDisplayContainer.innerHTML = '';
                socialsFormContainer.innerHTML = '';
                renderSocialsDisplay();
                document.querySelectorAll('#title-container, #gif-container, #timer-container, #socials-container').forEach(el => applyState(el, staticElementStateKey, defaultStaticStates));
            }
        });

		// Profiles events
		saveProfileBtn.addEventListener('click', saveCurrentAsProfile);
		loadProfileBtn.addEventListener('click', loadSelectedProfile);
		deleteProfileBtn.addEventListener('click', deleteSelectedProfile);
		profileSelect.addEventListener('change', () => { profileNameInput.value = profileSelect.value || ''; });
		document.getElementById('export-profiles-btn').addEventListener('click', () => {
			const data = getProfilesMap();
			const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = 'stream-profiles.json';
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
			URL.revokeObjectURL(url);
		});
		document.getElementById('import-profiles-btn').addEventListener('click', () => {
			document.getElementById('import-file-input').click();
		});
		document.getElementById('import-file-input').addEventListener('change', (e) => {
			const file = e.target.files && e.target.files[0];
			if (!file) return;
			const reader = new FileReader();
			reader.onload = () => {
				try {
					const imported = JSON.parse(reader.result);
					if (imported && typeof imported === 'object') {
						const existing = getProfilesMap();
						const merged = { ...existing, ...imported };
						saveProfilesMap(merged);
						refreshProfileList();
						alert('Profiles imported successfully.');
					} else {
						alert('Invalid profiles file.');
					}
				} catch {
					alert('Failed to parse profiles file.');
				}
			};
			reader.readAsText(file);
			// reset input
			e.target.value = '';
		});

        addTextBtn.addEventListener('click', () => addDynamicElement('text'));
        addImageBtn.addEventListener('click', () => addDynamicElement('image'));
        document.getElementById('add-gif-btn').addEventListener('click', () => addDynamicElement('gif'));
        document.getElementById('add-logo-btn').addEventListener('click', () => addDynamicElement('logo'));
        document.getElementById('add-banner-btn').addEventListener('click', () => addDynamicElement('banner'));
        document.getElementById('add-audio-btn').addEventListener('click', () => addDynamicElement('audio'));
        document.getElementById('add-sound-effect-btn').addEventListener('click', () => addDynamicElement('sound-effect'));
        document.getElementById('add-core-text-btn').addEventListener('click', () => addDynamicElement('core-text'));
        addSocialBtn.addEventListener('click', addSocial);
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !displayView.classList.contains('hidden')) { toggleView(); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'p') { e.preventDefault(); toggleView(); }
            if (!displayView.classList.contains('hidden')) {
                const step = e.shiftKey ? 10 : 1;
                if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)) {
                    e.preventDefault();
                    let dx = 0, dy = 0;
                    if (e.key === 'ArrowLeft') dx = -step;
                    if (e.key === 'ArrowRight') dx = step;
                    if (e.key === 'ArrowUp') dy = -step;
                    if (e.key === 'ArrowDown') dy = step;
                    const target = document.activeElement;
                    if (target && target.classList && target.classList.contains('interactive-element')) {
                        let x = (parseFloat(target.getAttribute('data-x')) || 0) + dx;
                        let y = (parseFloat(target.getAttribute('data-y')) || 0) + dy;
                        target.style.transform = `translate(${x}px, ${y}px)`;
                        target.setAttribute('data-x', x);
                        target.setAttribute('data-y', y);
                        const isStatic = !!defaultStaticStates[target.id];
                        const stateKey = isStatic ? staticElementStateKey : dynamicElementStateKey;
                        const parentWidth = displayView.clientWidth;
                        const parentHeight = displayView.clientHeight;
                        const newX = x / parentWidth; const newY = y / parentHeight;
                        if (isStatic) {
                            const savedStates = safeGetJSON(stateKey, { ...defaultStaticStates });
                            savedStates[target.id] = { ...(savedStates[target.id] || defaultStaticStates[target.id] || {}), x: newX, y: newY };
                            safeSetJSON(stateKey, savedStates);
                        } else {
                            const dynEl = dynamicElements.find(e => e.id === target.id);
                            if (dynEl) { dynEl.state.x = newX; dynEl.state.y = newY; saveDynamicElements(); }
                        }
                    }
                }
            }
        });
        
        window.addEventListener('resize', () => {
            if (!displayView.classList.contains('hidden')) {
                document.querySelectorAll('.interactive-element').forEach(el => {
                    const isStatic = !!defaultStaticStates[el.id];
                    const stateKey = isStatic ? staticElementStateKey : dynamicElementStateKey;
                    const defaults = isStatic ? defaultStaticStates : {};
                    applyState(el, stateKey, defaults);
});
            }
        });

    </script>
</body>
</html>